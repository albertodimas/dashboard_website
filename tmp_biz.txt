import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@dashboard/db'
import jwt from 'jsonwebtoken'

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production'

export async function GET(request: NextRequest) {
  try {
    console.log('üöÄ [businesses API] Request received')
    
    // Obtener el negocio referente desde la cookie
    const referringBusinessId = request.cookies.get('referring-business')?.value
    
    // Verificar token desde cookies
    const token = request.cookies.get('client-token')?.value
    console.log('üîë [businesses API] Cookie token:', token ? 'Present' : 'Missing')
    
    if (!token) {
      console.error('‚ùå [businesses API] No valid token cookie found')
      return NextResponse.json(
        { error: 'No autorizado' },
        { status: 401 }
      )
    }

    console.log('üîê [businesses API] Token recibido:', token.substring(0, 20) + '...')
    
    let decoded: any

    try {
      decoded = jwt.verify(token, JWT_SECRET)
      console.log('‚úÖ [businesses API] Token decodificado exitosamente:', {
        customerId: decoded.customerId,
        email: decoded.email
      })
    } catch (error: any) {
      console.error('‚ùå [businesses API] Error verificando token:', error.message)
      return NextResponse.json(
        { error: 'Token inv√°lido' },
        { status: 401 }
      )
    }

    // Primero obtener el email del customer del token
    const customerEmail = decoded.email
    
    if (!customerEmail) {
      return NextResponse.json(
        { error: 'Email no encontrado en el token' },
        { status: 400 }
      )
    }

    // Primero obtener un customer para tener la contrase√±a de referencia
    console.log('üîç [businesses API] Buscando customer con ID:', decoded.customerId)
    const referenceCustomer = await prisma.customer.findUnique({
      where: { id: decoded.customerId }
    })
    
    if (!referenceCustomer) {
      console.error('‚ùå [businesses API] Cliente no encontrado con ID:', decoded.customerId)
      return NextResponse.json(
        { error: 'Cliente no encontrado' },
        { status: 404 }
      )
    }
    
    console.log('‚úÖ [businesses API] Reference customer encontrado:', {
      id: referenceCustomer.id,
      email: referenceCustomer.email,
      hasPassword: !!referenceCustomer.password
    })
    
    // Obtener la lista de negocios desregistrados desde metadata
    const customerMetadata = referenceCustomer.metadata as any || {}
    const unregisteredBusinesses = customerMetadata.unregisteredBusinesses || []
    console.log('üö´ [businesses API] Negocios desregistrados:', unregisteredBusinesses)
    
    // Buscar TODOS los customers con el mismo email y contrase√±a
    const whereClause: any = {
      email: customerEmail.toLowerCase()
    }
    
    // Solo filtrar por contrase√±a si existe
    if (referenceCustomer.password) {
      whereClause.password = referenceCustomer.password
    }
    
    const allCustomersWithSameEmail = await prisma.customer.findMany({
      where: whereClause,
      include: {
        businesses: {
          where: {
            isActive: true
          },
          include: {
            business: {
              include: {
                category: {
                  select: {
                    id: true,
                    name: true,
                    slug: true,
                    icon: true,
                    color: true
                  }
                },
                _count: {
                  select: {
                    services: true,
                    appointments: true
                  }
                }
              }
            }
          }
        }
      }
    })

    console.log('üìä [businesses API] Customers encontrados con mismo email:', allCustomersWithSameEmail.length)
    
    // Combinar los negocios donde el cliente est√° registrado
    const myBusinessesPromises = allCustomersWithSameEmail.flatMap(customer => 
      customer.businesses.map(async businessCustomer => {
        const business = businessCustomer.business
        
        // Contar appointments espec√≠ficos de este customer en este negocio
        const appointmentCount = await prisma.appointment.count({
          where: {
            businessId: business.id,
            customerId: customer.id
          }
        })
        
        return {
          id: business.id,
          name: business.name,
          description: business.description,
          logo: business.logo,
          address: business.address,
          city: business.city,
          state: business.state,
          phone: business.phone,
          email: business.email,
          slug: business.slug,
          customSlug: business.customSlug,
          businessType: business.businessType,
          categoryId: business.categoryId,
          category: business.category,
          appointmentCount,
          serviceCount: business._count.services,
          customerId: customer.id,
          lastVisit: businessCustomer.lastVisit,
          totalVisits: businessCustomer.totalVisits
        }
      })
    )
    
    let myBusinesses = await Promise.all(myBusinessesPromises)
    
    // Filtrar los negocios desregistrados
    myBusinesses = myBusinesses.filter(business => !unregisteredBusinesses.includes(business.id))
    
    // Priorizar el negocio referente si existe
    if (referringBusinessId) {
      myBusinesses = myBusinesses.sort((a, b) => {
        // El negocio referente va primero
        if (a.id === referringBusinessId) return -1
        if (b.id === referringBusinessId) return 1
        // Luego ordenar por √∫ltima visita (m√°s reciente primero)
        const aVisit = a.lastVisit ? new Date(a.lastVisit).getTime() : 0
        const bVisit = b.lastVisit ? new Date(b.lastVisit).getTime() : 0
        return bVisit - aVisit
      })
    }
    
    console.log('üéØ [businesses API] Total de negocios encontrados (despu√©s de filtrar desregistrados):', myBusinesses.length)
    if (myBusinesses.length > 0) {
      console.log('üè¢ [businesses API] Negocios:', myBusinesses.map(b => ({ 
        name: b.name, 
        slug: b.customSlug || b.slug,
        customerId: b.customerId 
      })))
    }

    // Obtener las categor√≠as de los negocios donde ya est√° registrado
    const existingCategoryIds = myBusinesses
      .map(b => b.categoryId)
      .filter(Boolean) // Eliminar nulls

    // Obtener IDs de negocios donde ya est√° registrado
    const registeredBusinessIds = myBusinesses.map(b => b.id)

    // Obtener negocios sugeridos (de diferentes categor√≠as y donde no est√° registrado)
    const suggestedBusinesses = await prisma.business.findMany({
      where: {
        isActive: true,
        isBlocked: false,
        // Excluir negocios donde ya est√° registrado
        NOT: {
          id: {
            in: registeredBusinessIds
          }
        },
        // Excluir categor√≠as donde ya tiene negocios
        ...(existingCategoryIds.length > 0 && {
          OR: [
            { categoryId: null },
            {
              NOT: {
                categoryId: {
                  in: existingCategoryIds
                }
              }
            }
          ]
        })
      },
      select: {
        id: true,
        name: true,
        description: true,
        logo: true,
        address: true,
        city: true,
        state: true,
        phone: true,
        email: true,
        slug: true,
        customSlug: true,
        businessType: true,
        categoryId: true,
        category: {
          select: {
            id: true,
            name: true,
            slug: true,
            icon: true,
            color: true
          }
        },
        isPremium: true,
        _count: {
          select: {
            services: true,
            reviews: {
              where: {
                isPublished: true
              }
            }
          }
        },
        reviews: {
          where: {
            isPublished: true
          },
          select: {
            rating: true
          }
        }
      },
      orderBy: [
        { isPremium: 'desc' },
        { createdAt: 'desc' }
      ],
      take: 10 // Limitar a 10 sugerencias
    })

    // Calcular rating promedio para negocios sugeridos
    const suggestedWithRating = suggestedBusinesses.map(business => {
      const avgRating = business.reviews.length > 0
        ? business.reviews.reduce((sum, review) => sum + review.rating, 0) / business.reviews.length
        : 0
      
      return {
        ...business,
        rating: avgRating,
        reviewCount: business._count.reviews,
        serviceCount: business._count.services
      }
    })

    const response = {
      success: true,
      myBusinesses,
      suggestedBusinesses: suggestedWithRating
    }
    
    console.log('‚úÖ [businesses API] Respuesta exitosa:', {
      myBusinessesCount: myBusinesses.length,
      suggestedBusinessesCount: suggestedWithRating.length
    })
    
    return NextResponse.json(response)
  } catch (error) {
    console.error('‚ùå [businesses API] Error completo:', error)
    console.error('‚ùå [businesses API] Stack trace:', error instanceof Error ? error.stack : 'No stack')
    return NextResponse.json(
      { error: 'Error al obtener negocios' },
      { status: 500 }
    )
  }
}
